<!DOCTYPE html> 
<!--
    kmax: The declaration must be in the first line and should not contain any blank
          space. However, blank space will be ignored any other place except the
          first line.
-->

<html lang = "en">
    <head>
        <meta charset = "utf-8" />
        <link rel = "stylesheet" href = "css/style.css" >
        <!--kmax: Drop the type value because there is only css to decorate the page.-->
        <title>Dive Into HTML5</title>
        <!--[if lt IE 9]>
        <script  src = 
            "http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <!--kmax: To create the new elements which not exist in previous IE.-->
    </head>
    <body>
        <nav>
            <ul>
                <li><a href = "#">home</a></li>
                <li><a href = "blog.html">blog</a></li>
                <li><a href = "gallery.html">gallery</a></li>
                <li><a href = "about.htlm">about</a></li>
            </ul>
        </nav>


        <!--kmax: To talk about the embedded article here.-->
        <article> 
            <header>
                <time datetime = "2013-03-23T22:30:59-34:00" pubdate>
                    March 23, 2013 22:30pm EDT
                </time>
                <hgroup>
                    <h1>h1</h1>
                    <h2>h2</h2>
                </hgroup>
            </header>
<!--the header ends here.-->

<!--canvas-->
            <img id = "cat" src = "images/cat.png" alt = "sleeping cat"/>
            <canvas id = "e" width = "177" height = "113"></canvas>
            <script>
                window.onload = function() {
                    var canvas = document.getElementById("e");
                    var context = canvas.getContext("2d");
                    var cat = document.getElementById("cat");
                    context.drawImage(cat, 0, 0);
                }
            </script>
            <!--or create in JavaScript way.-->
            <script>
                var canvas = document.getElementById("e");
                var context = canvas.getContext("2d");
                var cat = new Image();
                cat.src = "images/cat.png";
                cat.onload = function() {
                    for (var x = 0, y = 0; x < 500 && y < 375; x += 50, y += 37){
                        context.drawImage(cat, x, y, 88, 56);
                        <!--88, 56 is the scale of the image.-->
                    }
                }
            </script>

<!--video-->
            <!--standard format that you should code.-->
            <video id = "movie" width = "320" height = "240" preload controls>
                <source src = "name.mp4" type = 'video/mp4; codecs = "avc1.42E01E, mp4a.40.2"' />
                <source src = "name.webm" type = 'video/webm; codecs = "vp8, vorbis"' />
                <source src = "name.ogv" type = 'video/ogg; codecs = "theora, vorbis"' />
                <object width = "320" height = "240" type = 
                    "application/x-shockwave-flash" data = "flowplayer-3.2.1.swf">
                    <param name = "movie" value = "flowplayer-3.2.1.swf" />
                    <param name = "allowfullscreen" value = "true" />
                    <param nuam = "flashvars" value = 'config = {
                        "clip":{
                        "url": "http://wearehugh.com/dih5/good/bbb_480p.mp4",
                        "autoPlay": false, "autoBuffering": true
                        }
                    }' />
                    <p>Download video as <a href = "name.mp4">MP4</a>, 
                        <a href = "name.webm">Webm</a>, or
                        <a href = "name.ogv">Ogv</a>.
                    </p>
                </object>
            </video>
            <footer>
                <nav>
                    <h1>Navigation</h1>
                    <ul>
                        <li><a href = "#">Home</a></li>
                        <li><a href = "#">Standards</a></li>
                        <li><a href = "#">Participate</a></li>
                        <li><a href = "#">Membership</a></li>
                        <li><a href = "#">About W3C</a></li>
                    </ul>
                </nav>
                <nav>
                    <h1>Contact W3C</h1>
                    <ul>
                        <li><a href = "#">Contact</a></li>
                        <li><a href = "#">Help and FAQ</a></li>
                        <li><a href = "#">Donate</a></li>
                        <li><a href = "#">Site Map</a></li>
                    </ul>
                </nav>
                <section>
                    <h1>W3C Updates</h1>
                    <ul>
                        <li><a href = "#">Twitter</a></li>
                        <li><a href = "#">Identi.ca</a></li>
                    </ul>
                </section>
                <p class = "copyright">Copyright @2013 W3C</p>
            </footer>
        </article>

    </body>
</html>



<!--

    HERE are valuable notes for my presentation:

#HTML development:
    ->1997 W3C published HTML4.0 and promptly shutdown the HTML Working Group.
    ->Less than 2 months later, a seperate W3C Working Group published XML1.0.
    ->Three months after that, the W3C held a workshop called "Shaping the Future 
      of HTML" to answer the question, "Has W3C given up on HTML?" This was the 
      answer:
          In discussion, it was agreed that further extending HTML4.0 would be 
          difficult, as would converting 4.0 to be an XML application. The 
          proposed way to break free of these restrictions is to make a fresh 
          start with the next generation of HTML based upon a suite of XML tag-sets.
    -> XHTML1.0 + Appendix C
    -> XHTML1.1 eliminate the Appendix C 
    -> Appendix C - down to html, loophole to escape the "draconian error handling"
    -> Actually, web pages claim to be XHTML are not using XHTML, still HTML.
    ->
    ...
    ->
    -> June 2004, the W3C held the Workshop on Web Applications and Compound Documents.
       They proposed a competing vision.
          Backward compatibility, clear migration path.
          Well-defined error handling.
          Users should not be exposed to authoring errors.
          Practical use.
          Scripting is here to say.
          Device-specific profiling should be avoided.
          Open process.
    -> A question was asked, "Should the W3C develop declarative extensions to 
       HTML and CSS and imperative extensions to DOM, to address medium level 
       Web Applications requirements, as opposed to sophisticated, fully-fledged 
       OS-level APIs?" The vote was 11 to 8 against.
    -> And WHAT Working Group was born.
         The Web Hypertext Applications Technology Working Group is a loose, unofficial 
         and open collaboration of Web browser manufacturers and interested parties.
    -> The create Web Forms 2.0, Web Application 1.0.
    -> W3C - Never-finalized XHTML2.0 continued the tradition of requiring DEH.
    -> In October 2006, W3C work together with the WHAT Working Group to evolve HTML.
       Rename "Web Application 1.0" to "HTML5". And here we are, diving into HTML5.


Clear some concepts:

#W3C
The World Wide Web Consortium (W3C) is an international community where Member 
organizations, a full-time staff, and the public work together to develop Web 
standards. Led by Web inventor Tim Berners-Lee and CEO Jeffrey Jaffe, W3C's 
mission is to lead the Web to its full potential.

#MIME 
Multipurpose Internet Mail Extensions (MIME) is an Internet standard that 
extends the format of email to support:
    •Text in character sets other than ASCII
    •Non-text attachments
    •Message bodies with multiple parts
    •Header information in non-ASCII character sets
// MIME类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文
件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的
文件名，以及一些媒体文件打开方式。
-----------------------------------------------------------------------------

#How HTML5 came to be.
    Implementations and specifications have to do a delicate dance together.
    // 标准和实现之间的矛盾
    Standards are hard to be made. 
        - Eg. 17-year-old conversation == a simple HTML element <img>

#Browsers have always been "forgving" with HTML. And because of that, by some 
estimates, over 99 persent of HTML pages on the Web today have at least one 
error in them. - "Everything you know about xhtml is wrong."

#Every time your web browser requests a page, the web server sends a numbers of 
headers before it sends the actual page markup. These headers are normally 
invisible, although there are a number of web development tools that will make 
them visible if you're interested. The headers are important, because they tell 
your browser how to interpret the page markup that follows. The most important 
header is called Content-Type, and it looks like this:
    Content-Type: text/html
text/html is called the "content type" or "MIME type" of the page. This header 
is the ONLY thing that determines what a particular resource truly is, and 
therefore how it should be rendered.


#HTML5 is not a big thing; it is a collection of individual features.
 You can detect support for individual features, like canvas, video and so on.

#Canvas - HTML5 defines the <canvas> element as "a resolution-dependent bitmap 
canvas which can be used for rendering graphs, game graphics, or other visual 
imaes on the fly." A canvas is a rectangle in your page within which you can 
use JavaScript to draw anything you want. HTML5 defines a set of functions("the 
canvas API") for drawing shapes, defining paths, creating gradients, and 
applying transformations.
  - You can use the double-negative trick to force the result to a Boolean value 
    return !!document.createElement('canvas').getContext;
  - webGL - 3d openGL // wait to complete.

#Video - HTML5 defines a new element called <video> for embedding video in your 
web pages. Embedding video used to be impossible without third-party plug-ins 
such as Apple QuickTime or Adobe Flash.
  - Kroc Camen has designed a solution called "Video for Everybody!" that uses 
    HTML5 video where available, but falls back to QuickTime or Flash in older 
    browser. This solution uses no JavaScript whatsoever, and it works in 
    virtually every browser, including mobile browsers.
  - For maximum compatibility, here's what your video workflow will look like:
        1. Make one version that uses Theora video and Vorbis audio in an Ogg 
           container.
        2. Make another version that uses WebM(VP8 + Vorbis).
        3. Make another version that use H.264 Baseline video and AAC 
           low-complexity audio in an MP4 container.
        4. Link to all three video files from a single <video> element, and fall 
           back to a Flash-based video player.


// standard of application
#LocalStorage - HTML5 Storage provides a way for websites to store information 
on your computer and retrieve it later. The concept is similar to cookies, but 
it's designed for larger quantities of information. Cookies are limited in size, 
and your browser sends them back to the web server every time it requests a new 
page (which takes extra time and precious bandwidth). HTML5 Storage stays on 
your computer, and websites can access it with JavaScript after the page is loaded.
    Within your browser, any website can read and modify its own values, but sites 
    can't access values stored by other sites. == same-origin restriction.

#Web Workers - provide a standard way for browsers to run JavaScript in the 
background. With web workers, you can spawn multiple "threads" that all run at 
the same time, more or less.
    These "background threads" can do complex mathematical calculations, make 
    network requests, or access local storage while the main web page responds 
    to the user scrolling, clicking, or typing.

#Offline Web Applications - Thanks to HTML5, anyone can build a web application 
that works offline.
    Once your browser downloads all the necessary files, you can revisit the 
    website even if you're not connected to the Internet. Your browser will 
    notice that you're offline and use the file it has already downloaded. When 
    you get back online, any changes you've made can be uploaded to the remote 
    web server.

#Geolocation - is the art of figuring out where you are in the world and (optionally)
sharing that information with people you trust. There are many ways to figure 
out where you are - your IP address, your wireless network connection, which 
cell tower your phone is talking to, or dedicated GPS hardware that receives 
latitude and logitude information from satellites in the sky.
    Geolocation is being standardized by the Geolocation Working Group, which is 
    separate from the HTML5 Working Group. But it is part of the evolution of 
    the Web that's happening now.
    If your browser does not support the geolocation API natively, there is 
    still hope. Gears is an open source browser plug-in from Google that works 
    on Windows, Mac, Linux, Windows Mobile, and Android. It provides a number of 
    features for older browsers that do not support all the fancy new stuff.
    And one of the features that Gears provides is a geolocation API.

#Input Types - many new input types

#Placeholder Text - is displayed inside the input field as long as the field is 
empty and not focused. As soon as you click on (or tab to) the input field, the 
placeholder texts disappears.

#Form Autofocus - moves the focus to a particular input field. But because it's 
just markup instead of a script, the behavior will be consistent across all websites.
Also, browser vendors(or extension authors) can offer users a way to disable the 
autofocusing behavior.

#Microdata - is a standardized way to provide additional semantics in your web 
pages. For example, you can use microdata to declare that a photograph is 
available under a specific Creative Common license.

//
#Web Socket

//
#Framework









W3C计划在2014年完成HTML5标准。

-->












